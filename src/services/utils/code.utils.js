const _ = require('lodash');
const crypto = require('crypto');

/**
 * Creates an object with the same keys as `object` and values generated by
 * recursively running each own enumerable string keyed property of `object` thru
 * `iteratee`. The `iteratee` is invoked with three arguments:
 * (value: any, fieldPath: Array, stack: Array, object: any)
 *
 * Where:
 * - value: is the currently iterated value
 * - fieldPath: path of the `value` in the final mapped object
 * - stack: the stack of mapped objects
 * - object: the original `object`
 *
 * @param {*} object
 * @param {Function} iteratee Function recursively called for every field of object.
 *   The `iteratee` is invoked with three arguments: (value: any, fieldPath: Array, rootValue: any).
 * @param {Object} [options]
 * @param {boolean} [options.thisArg] The value of `this` provided for the call to `iteratee`. Default: undefined
 * @param {boolean} [options.iterateCollections] Should the `iteratee` be called for collections. Default: true
 * @param {boolean} [options.iteratePrimitives] Should the `iteratee` be called for primitives. Default: true
 * @returns {*}
 */
function deepMap(object, iteratee, options) {
    const context = _.get(options, 'context');
    const iterateCollections = _.get(options, 'iterateCollections', true);
    const iteratePrimitives = _.get(options, 'iteratePrimitives', true);

    function _mapDeep(value, keyPath, objectStack, mappedObjectStack) {
        const invokeIteratee = (_.isPlainObject(value) || _.isArray(value)) ? iterateCollections : iteratePrimitives;
        const origValue = value;
        if (invokeIteratee) {
            value = iteratee.call(context, {
                value,
                keyPath,
                rootObject: object,
                objectStack,
                mappedObjectStack
            });
        }
        if (_.isPlainObject(value)) {
            value = _.mapValues(value, (val, key) => {
                return _mapDeep(val, _.concat(keyPath, key), _.concat(objectStack, origValue), _.concat(mappedObjectStack, value));
            });
        } else if (_.isArray(value)) {
            value = _.map(value, (val, key) => {
                return _mapDeep(val, _.concat(keyPath, key), _.concat(objectStack, origValue), _.concat(mappedObjectStack, value));
            });
        }
        return value;
    }

    return _mapDeep(object, [], [], []);
}

function mapToObject(map) {
    if (!map || !map.forEach) {
        return map;
    }
    const out = Object.create(null);
    map.forEach((value, key) => {
        if (value instanceof Map) {
            out[key] = mapToObject(value);
        }
        else {
            out[key] = value;
        }
    });
    return out;
}

function withRetry(f, { logger, maxRetry = 2, retryDelay = 0, retryCount = 0 } = {}) {
    return f().catch((err) => {
        if (retryCount > maxRetry) {
            if (logger) {
                logger.error('[retry] reached max retry. failing...', {retryCount, maxRetry, err});
            }
            throw err;
        }
        if (logger) {
            logger.warn('[retry] retrying operation', {retryCount, maxRetry, retryDelay, err});
        }
        return delayPromise(retryDelay).then(() => withRetry(f, {
            logger: logger,
            maxRetry,
            // double retry delay in case of consistent failing
            retryDelay: retryCount >= 1 ? retryDelay * 2 : retryDelay,
            retryCount: retryCount + 1 }));
    });
}

function delayPromise(delay) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, delay);
    });
}

function getRandomSecureString(len=20) {
    return crypto.randomBytes(len).toString('hex');
}

module.exports = {
    deepMap,
    mapToObject,
    withRetry,
    delayPromise,
    getRandomSecureString
};
